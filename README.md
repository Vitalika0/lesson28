# lesson28

  1.Для сложения двух положительных целых чисел, записанных в 8-разрядные ячейки, нужно сложить соответствующие разряды столбиком, начиная с младшего разряда. Если в полученной сумме есть разряд, который больше 1, то в текущий разряд результата записывается последняя цифра этой суммы, а в следующий разряд переносится 1.

  2.Дополнительный код — наиболее распространённый способ представления отрицательных целых чисел в компьютерах. Алгоритм получения кода числа: если число положительное, то в старший разряд записывается ноль, а далее записывается само число, если число отрицательное, то код получается инвертированием представления модуля числа.

  3.Причиной переполнения может служить суммирование двух чисел с одинаковыми знаками, которые в сумме дают величину, большую или равную 1 и величины rn.

  4.Арифмеетико-логическое устроойство.

  5.В большинстве компьютеров операция вычитания не используется. Вместо нее производится сложение обратных или дополнительных кодов уменьшаемого и вычитаемого. Это позволяет существенно упростить конструкцию АЛУ.

  6.Нет

  7.Сложение и вычитание требуются не только для расчётов по формулам, но и для организации вычислений.

  8.Поразрядные операции выполняются над отдельными разрядами или битами чисел. Данные операции производятся только над целыми числами. Но сначала вкратце рассмотрим, что представляют собой разряды чисел.

  9.Потому что это разные операции.

  10.Маска представляет собой последовательность букв, цифр и прочих допустимых в именах файлов символов.

  11.Для сброса конкретного бита, не трогая другие, нужно выполнить битовое AND с маской типа 11111011. А маску такую чтобы сделать - можно, например, выполнить сдвиг единицы влево, затем инвертировать.

  12.Взять и убрать.

  13.Для сброса конкретного бита, не трогая другие, нужно выполнить битовое AND с маской типа 11111011. А маску такую чтобы сделать - можно, например, выполнить сдвиг единицы влево, затем инвертировать

  14.Взять и убрать.

  15.С помощью маски.

  16.Установка или сброс битов двоичного кода может быть использована, например, в задачах контроля доступа, кодирования информации, определения состояния устройств, изменения настроек и т.д

  17.Операция «исключающее или» (XOR) обладает следующими возможностями: 1 Замкнутость. В результате этой операции два n-битовых слова дают другое n-битовое слово. 2 Ассоциативность. Позволяет использовать больше чем одно «исключающее или», которые можно вычислять в любом порядке. 3 Коммутативность. Позволяет менять местами операторы (входную информацию), не изменяя результат (выходную информацию). 4 Существование нулевого (тождественного) элемента. Нулевой элемент для операции «исключающее или» — слово, которое состоит из всех нулей. 5 Существование инверсии. В поле GF(2n) каждое слово является аддитивной инверсией самого себя.

  18.Алгоритм шифрования кода с использованием операции "исключающее ИЛИ" может быть следующим:
Используем случайно генерируемую ключевую маску с таким же размером, как и исходное сообщение.
Применяем операцию "исключающее ИЛИ" между ключевой маской и исходным сообщением.
Полученный результат будет зашифрованным кодом сообщения.
Для расшифровки нужно применить операцию "исключающее ИЛИ" между зашифрованным кодом и ключевой маской.

  19.Для определения совпадают или нет биты S' и S при выполнении сложения, можно использовать операцию "исключающее ИЛИ" между этими битами. Если результат будет равен 0, значит биты совпадают, иначе они не совпадают.

  20.Операция "НЕ" играет роль при получении отрицательных чисел в представлении в дополнительном коде. Применение операции "НЕ" к числу инвертирует каждый бит числа.

  21.Для инверсии всех битов числа без использования операции "НЕ" можно применить операцию "ИСКЛЮЧАЮЩЕЕ ИЛИ" числа с маской, которая имеет все биты установлены в 1.

  22.Сдвиг — это перемещение всех битов первого операнда (байта или слова) влево или вправо на число, заданное вторым операндом. Существуют следующие виды сдвига: 1 Логический сдвиг влево (shl). 2 Арифметический сдвиг влево (sal). 3 Логический сдвиг вправо (shr). 4 Арифметический сдвиг вправо (sar). 5 Циклический сдвиг влево (rol). 6 Циклический сдвиг вправо (ror). 7 Циклический сдвиг влево через перенос (rcl). 8 Циклический сдвиг вправо через перенос (rcr).

  23.При различных типах сдвига самый старший и самый младший биты могут обрабатываться по-разному. Например, при арифметическом сдвиге вправо самый старший бит сохраняется, при логическом сдвиге вправо - самый старший бит заполняется нулем, а при циклическом сдвиге вправо - самый старший бит становится младшим.

  24.Сдвиг влево двоичного кода удваивает число, потому что при каждом сдвиге влево каждый разряд умножается на 2. Сдвиг вправо уменьшает число вдвое, потому что при каждом сдвиге вправо каждый разряд делится на 2.

  25.Логический сдвиг не годится для уменьшения в два раза отрицательных чисел, потому что он не сохраняет знак числа. Арифметический сдвиг, в отличие от логического, сохраняет знак числа. При арифметическом сдвиге вправо отрицательные числа уменьшаются вдвое, а при сдвиге влево увеличиваются вдвое.

  26.-

  27.Правило вычисления результата арифметического сдвига отрицательного нечётного числа на один разряд вправо следующее:
Каждый разряд числа сдвигается на один разряд вправо.
Самый старший разряд заполняется единицей, если знак числа отрицательный, иначе нулем.
Знак числа остается неизменным. Это правило применимо и к положительным нечетным числам. Формула упрощается для четных исходных значений, так как после арифметического сдвига четного числа на один разряд вправо, результат будет равен половине исходного числа.

  28.-

  ЗАДАЧИ:
  1.00011111^2 + 00010011^2 = 00110010^2
  
  2.11100001^2 + 00010011^2 = 11110100^2
  
  3.Задача №3 ответ,.
  
  4.1011111^2; 11011111^2
  
  5.1100^2 ⋅ 111^2 = 1010100^2

  6.11110100^2 ⋅ 111^2 = 10101100^2
  
  7.Коля просто догадался применить переместительный закон для умножения, переставив
сомножители.

  8.119 и 136, 119 и –120
  
  9.кодЗаглавной = кодСтрочной and DF^16
  
  10.кодСтрочной = кодЗаглавной or 20^16
  
  11.Решение Коли приводит к неправильным ответам, когда сумма цифр больше 15.
  
  12.4, 8, 16 – все они делятся нацело на 4
  
  13.X and1 = 0 , X and 7 = 0 , X and F = 0 ,
  
  14.a:=a xor b; b:=b xor a; a:=a xor b;
  
  15.R:= X shr 16; G:=(X shr 8) & F^16; B:= X & F^16;
  
  16.Правильны оба решения, но у Коли рациональнее.
  
  17.Y:=(X shl 4) shr 4; Z:=(X shr 4) shl 4;
  
  18.При использовании 16‐битных данных: EDC0^16, EDCF^16.
  
  19.При использовании 16‐битных данных: 0123^16, 4123^16, 0123^16; 0FED^16, CFED^16, FFED^16
  
  20.EE16, 7716 = 119 = (256 – 18)/2, F716 = –9
  
  21.FF^16, FF^16, FF^16
  
  22.Z = 11002 = 12 Z = Z shl 1 = 11000^2 X = Z = 11000^2 X = X shl 2 = 1100000^2 X = X + Z = 1111000^2 = 120
  
